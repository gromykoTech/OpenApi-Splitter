# Архитектура SPA

OpenAPI Splitter построен как Single Page Application (SPA) на React с использованием TypeScript. Приложение работает полностью на клиенте, без серверной части.

## Общая архитектура

### Тип приложения

- **SPA (Single Page Application)**: одностраничное приложение, все взаимодействие происходит без перезагрузки страницы
- **Клиентская обработка**: вся бизнес-логика выполняется в браузере
- **Статическая сборка**: приложение собирается в статические файлы через Vite

### Технологический стек

- **React 19.2.0** — декларативная библиотека для построения UI
- **TypeScript 5.9.3** — типизация для безопасности типов
- **Vite 7.2.4** — сборщик и dev-сервер
- **Zustand** — управление глобальным состоянием
- **CodeMirror 6** — редактор кода с подсветкой синтаксиса
- **Tailwind CSS 4.1.18** — utility-first CSS фреймворк

## Структура проекта

Проект организован по принципу **feature-based architecture** (архитектура по фичам):

```
src/
├── main.tsx              # Точка входа приложения
├── App.tsx               # Корневой компонент
├── layouts/              # Компоненты макетов
│   └── MainLayout.tsx
├── stores/               # Глобальное состояние (Zustand)
│   └── splitterStore.ts
├── features/             # Фичи приложения
│   └── splitter/
│       ├── components/   # UI компоненты
│       ├── hooks/        # React хуки с бизнес-логикой
│       ├── services/     # Чистые функции и сервисы
│       └── types/        # TypeScript типы
└── core/                 # Общие ресурсы
    └── assets/
        └── css/
```

### Принципы организации

1. **Feature-based**: код группируется по функциональности, а не по типу файлов
2. **Separation of Concerns**: разделение UI, логики и данных
3. **Reusability**: переиспользуемые компоненты и сервисы
4. **Type Safety**: строгая типизация на всех уровнях

## Управление состоянием

### Zustand Store

Глобальное состояние управляется через Zustand store (`src/stores/splitterStore.ts`):

```typescript
type SplitterState = {
  inputText: string;          // Введенный YAML текст
  fileTree: FileNode[];        // Дерево файлов после разбиения
  selectedCode: string;        // Выбранный файл для просмотра
  isProcessing: boolean;       // Флаг обработки
  error: string | null;        // Ошибки
  yamlErrors: YamlError[];     // Ошибки валидации YAML
  isYamlValid: boolean;        // Валидность YAML
  lastProcessedHash?: string;  // Хеш последнего обработанного файла
};
```

### Преимущества Zustand

- **Легковесность**: проще Redux для проектов без сложной логики
- **Производительность**: эффективен для частых обновлений
- **Простота**: минимальный boilerplate код
- **TypeScript**: полная поддержка типизации

## Компонентная архитектура

### Иерархия компонентов

```
App
└── MainLayout
    └── OpenApiSplitter
        ├── InputSection
        │   └── YamlEditor
        ├── FileTree
        └── CodeViewer
```

### Типы компонентов

1. **Container Components** (`App.tsx`):
   - Тонкие компоненты-контейнеры
   - Подключают хуки с бизнес-логикой
   - Передают данные в презентационные компоненты

2. **Presentational Components** (`OpenApiSplitter`, `FileTree`, `CodeViewer`):
   - Отвечают только за отображение
   - Получают данные через props
   - Мемоизированы для оптимизации ререндеров

3. **Layout Components** (`MainLayout`):
   - Определяют общую структуру страницы
   - Обеспечивают консистентный layout

### Оптимизация производительности

- **React.memo**: мемоизация компонентов для предотвращения лишних ререндеров
- **useMemo**: мемоизация вычислений
- **useCallback**: мемоизация функций-обработчиков
- **Zustand selectors**: подписка только на нужные части состояния

## Бизнес-логика

### React Hooks

Бизнес-логика вынесена в кастомные хуки:

1. **`useOpenApiSplitter`** (`src/features/splitter/hooks/useOpenApiSplitter.ts`):
   - Оркестрация процесса разбиения OpenAPI
   - Управление асинхронными операциями
   - Защита от race conditions через `AbortController`
   - Интеграция с валидацией

2. **`useYamlValidation`** (`src/features/splitter/hooks/useYamlValidation.ts`):
   - Валидация YAML в реальном времени
   - Debounce для оптимизации производительности
   - Обновление состояния валидности в store

### Защита от race conditions

```typescript
const abortControllerRef = useRef<AbortController | null>(null);

const cancelPreviousOperation = () => {
  if (abortControllerRef.current) {
    abortControllerRef.current.abort();
  }
  abortControllerRef.current = new AbortController();
  return abortControllerRef.current.signal;
};
```

При быстрых действиях пользователя (множественные клики, загрузка нового файла) предыдущая операция отменяется, чтобы избежать конфликтов состояний.

## Сервисный слой

Сервисы содержат чистые функции без побочных эффектов:

### Основные сервисы

1. **`openApiSplitter.ts`**:
   - Функция `splitOpenApiYaml()` — разбиение YAML на файлы
   - Рекурсивный обход структуры
   - Сохранение абсолютных `$ref`

2. **`yamlValidator.ts`**:
   - Валидация синтаксиса YAML
   - Форматирование YAML
   - Извлечение ошибок с позициями

3. **`exportToZip.ts`**:
   - Экспорт файлового дерева в ZIP-архив
   - Рекурсивный сбор файлов
   - Создание архива через `fflate`

4. **`openApiParser.ts`**:
   - Интерфейс парсинга OpenAPI
   - Валидация структуры

### Принципы сервисов

- **Чистые функции**: без побочных эффектов
- **Изолированность**: не зависят от UI
- **Тестируемость**: легко тестируются изолированно
- **Переиспользуемость**: могут использоваться в разных контекстах

## Потоки данных

### Односторонний поток данных

```
User Input
    ↓
Component Event Handler
    ↓
Hook (useOpenApiSplitter)
    ↓
Service (splitOpenApiYaml)
    ↓
Zustand Store (setFileTree)
    ↓
Component Re-render
```

### Пример потока: разбиение OpenAPI

1. **Пользователь вводит YAML** → `setInputText()` → Store
2. **Валидация в реальном времени** → `useYamlValidation` → Store
3. **Нажатие "Разделить файл"** → `handleSplit()` → `processSplit()`
4. **Парсинг и разбиение** → `splitOpenApiYaml()` → `SplitResult`
5. **Обновление состояния** → `setFileTree()` → Store
6. **Ререндер компонентов** → `FileTree`, `CodeViewer`

## Обработка ошибок

### Стратегия обработки ошибок

1. **Валидация YAML**: ошибки отображаются в реальном времени под редактором
2. **Ошибки обработки**: отображаются в блоке ошибок в `InputSection`
3. **Race conditions**: отменяются через `AbortController`, ошибки игнорируются
4. **Ошибки экспорта**: логируются в консоль, UI не блокируется

### Состояния ошибок

- `error: string | null` — общие ошибки обработки
- `yamlErrors: YamlError[]` — ошибки валидации YAML с позициями
- `isYamlValid: boolean` — флаг валидности YAML

## Производительность

### Оптимизации

1. **Мемоизация компонентов**: `React.memo` для тяжелых компонентов (`FileTree`, `CodeViewer`)
2. **Debounce валидации**: задержка 300ms для валидации YAML
3. **Ленивая загрузка**: компоненты загружаются по требованию
4. **Оптимизация ререндеров**: селекторы Zustand для подписки на нужные части состояния
5. **Виртуализация**: для больших деревьев файлов (при необходимости)

### Обработка больших файлов

- Асинхронная обработка через `async/await`
- Индикатор загрузки во время обработки
- Блокировка UI во время обработки
- Предупреждения для файлов > 1MB

## Типизация

### TypeScript типы

Все данные типизированы:

```typescript
// Типы данных
type FileNode = {
  id: string;
  name: string;
  path: string;
  content?: string;
  children?: FileNode[];
};

type OpenApiDocument = {
  openapi?: string;
  info?: Record<string, unknown>;
  paths?: Record<string, unknown>;
  components?: Record<string, unknown>;
  [key: string]: unknown;
};
```

### Преимущества типизации

- **Безопасность типов**: ошибки обнаруживаются на этапе компиляции
- **Автодополнение**: улучшенный DX в IDE
- **Документация**: типы служат документацией API
- **Рефакторинг**: безопасный рефакторинг с проверкой типов

## Стилизация

### Tailwind CSS

- **Utility-first**: использование утилитарных классов
- **Responsive**: адаптивный дизайн через breakpoints (`lg:`, `md:`)
- **Кастомные скроллбары**: стилизация через CSS
- **Темная тема**: встроенная темная цветовая схема

### Структура стилей

- Глобальные стили: `src/core/assets/css/index.css`
- Компонентные стили: через Tailwind классы в JSX
- Кастомные скроллбары: WebKit и Firefox

## Сборка и развертывание

### Vite

- **Dev-сервер**: hot module replacement (HMR)
- **Production build**: оптимизированная сборка в `dist/`
- **Code splitting**: автоматическое разделение кода
- **Tree shaking**: удаление неиспользуемого кода

### Структура сборки

```
dist/
├── index.html
├── assets/
│   ├── index-[hash].js
│   └── index-[hash].css
```

## Заключение

Архитектура OpenAPI Splitter следует современным практикам разработки SPA:

- **Модульность**: четкое разделение ответственности
- **Масштабируемость**: легко добавлять новые фичи
- **Производительность**: оптимизация на всех уровнях
- **Поддерживаемость**: понятная структура и типизация
- **Тестируемость**: изолированные сервисы и компоненты

Приложение полностью клиентское, не требует серверной части и может быть развернуто как статический сайт.

